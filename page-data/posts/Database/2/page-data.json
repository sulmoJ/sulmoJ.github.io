{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/Database/2","result":{"data":{"markdownRemark":{"id":"86bcc849-0466-5b0e-92b8-ebea670af6a6","html":"<h3 id=\"db에서-index\" style=\"position:relative;\"><a href=\"#db%EC%97%90%EC%84%9C-index\" aria-label=\"db에서 index permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DB에서 Index</h3>\n<p>Database에서 index는 원하는 값을 조회할때, 말그대로 색인을 통해 값을 더 빠르게 찾기위한 추가적인 장치?입니다. 값과 해당 레코드가 저장된 주소를 메모리에 key와 value로 인덱스를 저장하여 사용합니다.</p>\n<p>하지만 일반적으로 인덱싱이 모든 작업에서 효율적이진 못한데 이유는, 인덱스가 저장될 때 정렬이 된 상태로 저장됨으로 조회가 아닌 생성이나 삭제를 할때 순서에 맞게 공간을 만들고 이후의 데이터를 한틱씩 미루거나 당기는 작업이 추가적으로 발생하게 됩니다. 수정 또한 인덱스 자체에는 수정기능이 따로 없어 삭제 후 재생성 방식이라 부하가 더 심할수도 있다고 합니다.</p>\n<ul>\n<li>장점 : 테이블 조회 속도 향상, 전반적인 시스템 부하를 줄임</li>\n<li>\n<p>단점</p>\n<ul>\n<li>인덱스를 추가적으로 관리해야하기 때문에 추가적인 저장공간이 필요</li>\n<li>인덱스 관리를 위한 추가작업이 필요</li>\n<li>잘못 사용시 역효과</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"index-자료구조\" style=\"position:relative;\"><a href=\"#index-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\" aria-label=\"index 자료구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Index 자료구조</h4>\n<p>그렇다면 인덱싱 알고리즘 중 대표적인 것들을 정리해 보겠습니다.</p>\n<h5 id=\"btree와-b-tree\" style=\"position:relative;\"><a href=\"#btree%EC%99%80-b-tree\" aria-label=\"btree와 b tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>B+Tree와 B-Tree</h5>\n<p>일반적인 이진 트리는 자식의 개수가 2개라는 약점이 있다. 그리고 균형이 맞지 않으면 검색 효율이 떨어지는 단점이 있는데 이를 개선하고자 하는 노력이 있었고</p>\n<ul>\n<li>B-tree\n그 중에서 B-Tree는 이진트리를 확장해 더 많은 수의 자식을 가질 수 있게 일반화 했고 합니다. 그리고 스스로 균형을 맞추는 로직을 갖추었다. (최악의 경우에도 O(logN))</li>\n<li>B+tree\nB+Tree는 B-Tree의 순회작업이 꽤 난감하여 인덱스로 해결을 봤다. B-tree는 특정 key값이 하나의 노드에서만 조재 할 수 있지만 B+tree는 단말노드와 단말노드의 부모노드와 공존이 가능하다. (기존 B-tree + 데이터의 연결 리스트)\n<img src=\"img/B+tree%20index.jpeg\" alt=\"BtreeIndex\">\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c4ea7a22cd396a9bdfbd8fedf10d30fe/ec605/B%2Btree.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.166666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB2wUH/8QAFxAAAwEAAAAAAAAAAAAAAAAAABESIf/aAAgBAQABBQJjyj//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAXEAADAQAAAAAAAAAAAAAAAAAAASER/9oACAEBAAE/Id4LEKiipn//2gAMAwEAAgADAAAAEIAP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHRABAAIBBQEAAAAAAAAAAAAAAQARITFBUcHR8P/aAAgBAQABPxAZ4bdGj2YpLb/MQAh5KO5//9k='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n        <source\n          srcset=\"/static/c4ea7a22cd396a9bdfbd8fedf10d30fe/8ac56/B%2Btree.webp 240w,\n/static/c4ea7a22cd396a9bdfbd8fedf10d30fe/d3be9/B%2Btree.webp 480w,\n/static/c4ea7a22cd396a9bdfbd8fedf10d30fe/e46b2/B%2Btree.webp 960w,\n/static/c4ea7a22cd396a9bdfbd8fedf10d30fe/5543b/B%2Btree.webp 1125w\"\n          sizes=\"(max-width: 960px) 100vw, 960px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/c4ea7a22cd396a9bdfbd8fedf10d30fe/09b79/B%2Btree.jpg 240w,\n/static/c4ea7a22cd396a9bdfbd8fedf10d30fe/7cc5e/B%2Btree.jpg 480w,\n/static/c4ea7a22cd396a9bdfbd8fedf10d30fe/6a068/B%2Btree.jpg 960w,\n/static/c4ea7a22cd396a9bdfbd8fedf10d30fe/ec605/B%2Btree.jpg 1125w\"\n          sizes=\"(max-width: 960px) 100vw, 960px\"\n          type=\"image/jpeg\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          src=\"/static/c4ea7a22cd396a9bdfbd8fedf10d30fe/6a068/B%2Btree.jpg\"\n          alt=\"Btree\"\n          title=\"Btree\"\n          loading=\"lazy\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        />\n      </picture>\n  </a>\n    </span></li>\n</ul>\n<h5 id=\"hash-인덱스-알고리즘\" style=\"position:relative;\"><a href=\"#hash-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"hash 인덱스 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hash 인덱스 알고리즘</h5>\n<p>칼럼 값으로 해시 값을 계산해서 인덱싱하는 알고리즘. 특정 문자로 시작하는 값을 검색하는 전방 일치처럼 값의 일부만으로 검색하고자 할때는 사용 불가.</p>\n<h5 id=\"index를-생성시-b-tree를-주로-사용하는지\" style=\"position:relative;\"><a href=\"#index%EB%A5%BC-%EC%83%9D%EC%84%B1%EC%8B%9C-b-tree%EB%A5%BC-%EC%A3%BC%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EC%A7%80\" aria-label=\"index를 생성시 b tree를 주로 사용하는지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>index를 생성시 b-tree를 주로 사용하는지</h5>\n<p>1대1로 매칭되어 찾아오는건 분명 Hash가 빠르지만 부등호(&#x3C;>)연산에선 b-tree가 더 효율적이기 때문</p>\n<h5 id=\"primary-index-vs-secondary-index\" style=\"position:relative;\"><a href=\"#primary-index-vs-secondary-index\" aria-label=\"primary index vs secondary index permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Primary Index vs Secondary Index</h5>\n<ul>\n<li>Primary Index(기본 인덱스)\n기본키를 포함하는 인덱스 (키의 순서가 레코드의 순서를 결정)\n[ 기본키 | 포인터 ] 구성으로 인덱스테이블이 생성\n<strong>Clustered Index</strong>라고 도 부름</li>\n<li>\n<p>Secondary Index (보조 인덱스)\n후보키인 필드로 인덱싱 생성. 모든 레코드에서 고유하거나 중복된 값이 있는 키가아닌 값으로 인덱싱함</p>\n<p>예시로 한 테이블에서 사람이름을 키워드로 조회를하면, 동명이인이 존재할 수 있기 떄문에 구분을 위해 추가적으로 보조 인덱스를 사용한다고 합니다.</p>\n</li>\n</ul>\n<h5 id=\"composite-index\" style=\"position:relative;\"><a href=\"#composite-index\" aria-label=\"composite index permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composite Index</h5>\n<p>겹합 인덱스는 두개 이상의 컬럼을 합쳐 인덱스를 만듭니다.\n어떤 속성으로 만드는지 그리고 어떤 조건을 먼저 걸러내는지에 따라 성능차이가 날수 있습니다.</p>\n<p>예시) 성별과 이름이 있다고 가정시 이름으로 찾고 그다음 성별을 찾을 때가 효율이 좋습니다.\n동명이인이 있는 명수보다 성별이 중복될 확률이 훨씬높기 때문입니다.</p>\n<p>그래서 결합 인덱스는 처음 거를때 최대한 많이 걸러 낼수 있는 조건을 먼저 실행하는게 좋습니다.</p>\n<h5 id=\"index의-성능과-고려해야할-사항\" style=\"position:relative;\"><a href=\"#index%EC%9D%98-%EC%84%B1%EB%8A%A5%EA%B3%BC-%EA%B3%A0%EB%A0%A4%ED%95%B4%EC%95%BC%ED%95%A0-%EC%82%AC%ED%95%AD\" aria-label=\"index의 성능과 고려해야할 사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Index의 성능과 고려해야할 사항</h5>\n<ul>\n<li>카디널리티(해당 필드의 고유값 수)가 낮은 속성은 인덱스로 사용하지 않는다.</li>\n<li>읽기에는 효과적이지만, 쓰기, 삭제, 수정에는 비용이 더 많이들 수 있다.</li>\n</ul>\n<h4 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h4>\n<ul>\n<li><a href=\"https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Plus-Tree\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">B+tree</a></li>\n<li><a href=\"https://www.tutorialspoint.com/dbms/dbms_indexing.htm\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">primary, secondary Index</a></li>\n<li><a href=\"https://stackoverflow.com/questions/20824686/what-is-difference-between-primary-index-and-secondary-index-exactly\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">primary, secondary Index(스오플)</a></li>\n<li><a href=\"https://user3141592.medium.com/single-vs-composite-indexes-in-relational-databases-58d0eb045cbe\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Composite index</a></li>\n</ul>","fields":{"slug":"/posts/Database/2","tagSlugs":["/tag/database/"]},"frontmatter":{"date":"2021-08-09T00:00:00","description":" Index란 Index의 자료구조 Primary index vs Secondary index Composite index Index의 성능과 고려해야할 사항","tags":["Database"],"title":"데이터베이스 Index","socialImage":{"publicURL":"/static/624cc4a835e68430a8beec01cef8ac6c/photo.jpg"}}}},"pageContext":{"slug":"/posts/Database/2"}},"staticQueryHashes":["251939775","401334301","825871152"]}